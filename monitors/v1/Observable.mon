package com.industry.rx_epl;

using com.apama.exceptions.Exception;

event _ForwardToChannel {
	string channelName;
	
	static action create(string channelName) returns action<any> {
		return _ForwardToChannel(channelName).forwardValueToChannel;
	}
	
	action forwardValueToChannel(any value) {
		send Value(channelName, value) to channelName;
	}
}

event _ForwardCompletedToMultipleChannels {
	sequence<string> channelNames;
	
	static action create(sequence<string> channelNames) returns action<> {
		return _ForwardCompletedToMultipleChannels(channelNames).sendMultipleCompleted;
	}
	
	action sendMultipleCompleted() {
		string channel;
		for channel in channelNames {
			send Complete(channel) to channel;
		}
	}
}

event _ForwardErrorToChannel {
	string channelName;
	
	static action create(string channelName) returns action<Exception, any> {
		return _ForwardErrorToChannel(channelName).forwardErrorToChannel;
	}
	
	action forwardErrorToChannel(Exception e, any value) {
		send Error(channelName, e, value) to channelName;
	}
}

event ListenerWrapper {
	listener l;
	
	action quit() {
		l.quit();
	}
}

event _CancelListenersAndSendErrors {
	sequence<string> channelNames;
	sequence<ListenerWrapper> listeners;
	
	static action create(sequence<string> channelNames, sequence<ListenerWrapper> listeners) returns action<Exception, any> {
		return _CancelListenersAndSendErrors(channelNames, listeners).cancelListenersAndSendErrors;
	}
	
	action cancelListenersAndSendErrors(Exception e, any value) {
		ListenerWrapper l;
		for l in listeners {
			l.quit();
		}
		string channel;
		for channel in channelNames {
			send Error(channel, e, value) to channel;
		}
	}
}

event IntegerWrapper {
	integer i;
	
	action increment() {
		i := i + 1;
	}
	
	action decrement() {
		i := i - 1;
	}
	
	action isZero() returns boolean {
		return i = 0;
	}
	
	action equals(integer j) returns boolean {
		return i = j;
	}
}

event Subscription {
	string channelName;
	boolean isConnected;
	
	static action create(string channelName) returns Subscription {
		return Subscription(channelName, false);
	}
	
	action disconnect() returns Subscription {
		if isConnected {
			send Unsubscribe(channelName) to channelName;
			isConnected := false;
		}
		return self;
	}
	
	action connect() returns Subscription {
		if not isConnected {
			send Subscribe(channelName) to channelName; 
			isConnected := true;
		}
		return self;
	}
}

event Observable {
	string channelName;
	IntegerWrapper subscriptionCount;
	
	action createLinkedWithName(string linkedChannelName) returns Observable {
		monitor.subscribe(linkedChannelName);
		on Subscribe(channelName = linkedChannelName) {
			send Subscribe(channelName) to channelName;
		}
		on Unsubscribe(channelName = linkedChannelName) {
			send Unsubscribe(channelName) to channelName;
		}
		
		return createWithName(linkedChannelName);
	}
	
	static action createWithName(string channelName) returns Observable {
		monitor.subscribe(channelName);
		Observable result := Observable(channelName, IntegerWrapper(0));
		on Subscribe(channelName = channelName) {
			result.subscriptionCount.increment();
		}
		on Unsubscribe(channelName = channelName) {
			result.subscriptionCount.decrement();
		}
		return result;
	}
	
	static action create() returns Observable {
		return createWithName("Observable" + integer.getUnique().toString());
	}
	
	static action ofWithName(sequence<any> values, string newChannelName) returns Observable {
		Observable result := Observable.createWithName(newChannelName);
		
		monitor.subscribe(newChannelName);
		on completed Subscribe(channelName = newChannelName) {
			any value;
			for value in values {
				send Value(newChannelName, value) to newChannelName;
			}
			send Complete(newChannelName) to newChannelName;
		}
		
		return result;
	}
	
	static action of(sequence<any> values) returns Observable {
		return ofWithName(values, "Observable"+integer.getUnique().toString());
	}
	
	action subscribeDisconnected(SubscriptionHandler subscription) returns Subscription {
		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		
		ifpresent subscription._onNext as onNext {
			valueListener.l := on all Value(channelName = channelName) as value {
				if not subscriptionCount.isZero() {
					try {
						onNext(value.value);
					} catch (Exception e) {
						valueListener.quit();
						errorListener.quit();
						completedListener.quit();
						send Error(channelName, e, value.value) to channelName;
					}
				}
			}
		}
		ifpresent subscription._onError as onError {
			errorListener.l := on Error(channelName = channelName) as error {
				onError(error.exception, error.errorValue);
				valueListener.quit();
				completedListener.quit();
			}
		} else {
			errorListener.l := on Error(channelName = channelName) as error {
				valueListener.quit();
				completedListener.quit();
				throw error.exception;
			}
		}
		ifpresent subscription._onCompleted as onCompleted {
			completedListener.l := on Complete(channelName = channelName) {
				onCompleted();
				valueListener.quit();
				errorListener.quit();
			}
		} else {
			completedListener.l := on Complete(channelName = channelName) {
				valueListener.quit();
				errorListener.quit();
			}
		}
		
		return Subscription.create(channelName);
	}
	
	action subscribe(SubscriptionHandler handler) returns Subscription {
		return subscribeDisconnected(handler).connect();
	}
	
	action mapWithName(action<any> returns any mapper, string newChannelName) returns Observable {
		Observable result := createLinkedWithName(newChannelName);
		
		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		
		valueListener.l := on all Value(channelName = channelName) as value {
			if not subscriptionCount.isZero() {
				try {
					send Value(newChannelName, mapper(value.value)) to newChannelName;
				} catch (Exception e) {
					valueListener.quit();
					errorListener.quit();
					completedListener.quit();
					send Error(channelName, e, value.value) to channelName;
					send Error(newChannelName, e, value.value) to newChannelName;
				}
			}
		}
		errorListener.l := on Error(channelName = channelName) as error {
			valueListener.quit();
			completedListener.quit();
			error.channelName := newChannelName;
			send error to newChannelName;
		}
		completedListener.l := on Complete(channelName = channelName) as complete {
			valueListener.quit();
			errorListener.quit();
			complete.channelName := newChannelName;
			send complete to newChannelName;
		}
		return result;
	}
	
	action map(action<any> returns any mapper) returns Observable {
		return mapWithName(mapper, "Observable" + integer.getUnique().toString());
	}
	
	action flatMapWithName(action<any> returns any mapper, string newChannelName) returns Observable {
		Observable result := createLinkedWithName(newChannelName);
		
		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		
		optional<Subscription> subscription := new optional<Subscription>;
		
		valueListener.l := on all Value(channelName = channelName) as value {
			if not subscriptionCount.isZero() {
				try {
					any flatMapResult := mapper(value.value);
					switch (flatMapResult as flatMapResult) {
						case Observable : {
							subscription := flatMapResult
								.subscribeDisconnected(SubscriptionHandler.create()
							                                    	.onNext(_ForwardToChannel.create(newChannelName))
							                                    	.onError(_CancelListenersAndSendErrors.create([channelName, newChannelName], [valueListener, errorListener, completedListener])));
							ifpresent subscription {
								monitor.subscribe(channelName);
								on all Subscribe(channelName = channelName) {
									send Subscribe(subscription.channelName) to subscription.channelName;
									subscription.isConnected := true;
								}
								on all completed Unsubscribe(channelName = channelName) {
									send Unsubscribe(subscription.channelName) to subscription.channelName;
									subscription.isConnected := not subscriptionCount.isZero();
								}
								integer i := 0;
								while i < subscriptionCount.i {
									send Subscribe(subscription.channelName) to subscription.channelName;	
									i := i + 1;
								}
							}
						}
						default : {
							any v;
							for v in flatMapResult.getEntries() {
								send Value(newChannelName, v) to newChannelName;
							}
						}
					}
				} catch (Exception e) {
					valueListener.quit();
					errorListener.quit();
					completedListener.quit();
					ifpresent subscription { 
						subscription := subscription.disconnect();
					}
					send Error(channelName, e, value.value) to channelName;
					send Error(newChannelName, e, value.value) to newChannelName;
				}
			}
		}
		errorListener.l := on Error(channelName = channelName) as error {
			valueListener.quit();
			completedListener.quit();
			ifpresent subscription { 
				subscription := subscription.disconnect();
			}
			error.channelName := newChannelName;
			send error to newChannelName;
		}
		completedListener.l := on Complete(channelName = channelName) as complete {
			// Async to allow the subscriptions and therefore values to be sent from any observables that have been flat mapped
			on wait(float.MIN) {
				valueListener.quit();
				errorListener.quit();
				ifpresent subscription { 
					subscription := subscription.disconnect();
				}
				complete.channelName := newChannelName;
				send complete to newChannelName;
			}
		}
		return result;
	}
	
	action flatMap(action<any> returns any mapper) returns Observable {
		return flatMapWithName(mapper, "Observable" + integer.getUnique().toString());
	}
	
	action areAllWithName(action<any> returns boolean predicate, string newChannelName) returns Observable {
		Observable result := createLinkedWithName(newChannelName);

		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		
		valueListener.l := on all Value(channelName = channelName) as value {
			if not subscriptionCount.isZero() {
				try {
					if not predicate(value.value) {
						valueListener.quit();
						errorListener.quit();
						completedListener.quit();
						send Value(newChannelName, false) to newChannelName;
						send Complete(channelName) to channelName;
						send Complete(newChannelName) to newChannelName;
					}
				} catch (Exception e) {
					valueListener.quit();
					errorListener.quit();
					completedListener.quit();
					send Error(channelName, e, value.value) to channelName;
					send Error(newChannelName, e, value.value) to newChannelName;
				}
			}
		}
		errorListener.l := on Error(channelName = channelName) as error {
			valueListener.quit();
			completedListener.quit();
			error.channelName := newChannelName;
			send error to newChannelName;
		}
		completedListener.l := on Complete(channelName = channelName) as complete {
			valueListener.quit();
			errorListener.quit();
			send Value(newChannelName, true) to newChannelName;
			complete.channelName := newChannelName;
			send complete to newChannelName;
		}
		
		return result;
	}
	
	action areAll(action<any> returns boolean predicate) returns Observable {
		return areAllWithName(predicate, "Observable" + integer.getUnique().toString());
	}
	
	action firstWithName(string newChannelName) returns Observable {
		return takeWithName(1, newChannelName);
	}
	
	action first() returns Observable {
		return takeWithName(1, "Observable" + integer.getUnique().toString());
	}
	
	action lastWithName(string newChannelName) returns Observable {
		Observable result := createLinkedWithName(newChannelName);

		Value mostRecentValue := new Value;
		
		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		
		valueListener.l := on all Value(channelName = channelName) as value {
			if not subscriptionCount.isZero() {
				mostRecentValue.value := value.value;
			}
		}
		errorListener.l := on Error(channelName = channelName) as error {
			valueListener.quit();
			completedListener.quit();
			error.channelName := newChannelName;
			send error to newChannelName;
		}
		completedListener.l := on Complete(channelName = channelName) as complete {
			valueListener.quit();
			errorListener.quit();
			ifpresent mostRecentValue.value as mostRecentValue {
				send Value(newChannelName, mostRecentValue) to newChannelName;
			}
			complete.channelName := newChannelName;
			send complete to newChannelName;
		}
		
		return result;
	}
	
	action last() returns Observable {
		return lastWithName("Observable" + integer.getUnique().toString());
	}
	
	action takeWithName(integer n, string newChannelName) returns Observable {
		Observable result := createLinkedWithName(newChannelName);

		IntegerWrapper i := new IntegerWrapper;
		
		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		
		valueListener.l := on all Value(channelName = channelName) as value {
			if not subscriptionCount.isZero() {
				i.increment();
				value.channelName := newChannelName;
				send value to newChannelName;
				if i.equals(n) {
					valueListener.quit();
					errorListener.quit();
					completedListener.quit();
					send Complete(channelName) to channelName;
					send Complete(newChannelName) to newChannelName;
				}
			}
		}
		errorListener.l := on Error(channelName = channelName) as error {
			valueListener.quit();
			completedListener.quit();
			error.channelName := newChannelName;
			send error to newChannelName;
		}
		completedListener.l := on Complete(channelName = channelName) as complete {
			valueListener.quit();
			errorListener.quit();
			complete.channelName := newChannelName;
			send complete to newChannelName;
		}
		
		return result;
	}
	
	action take(integer n) returns Observable {
		return takeWithName(n, "Observable" + integer.getUnique().toString());
	}
	
	action catchErrorWithName(action<Exception, any> returns any errorHandler, string newChannelName) returns Observable {
		Observable result := createLinkedWithName(newChannelName);
		
		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		valueListener.l := on all Value(channelName = channelName) as value {
			if not subscriptionCount.isZero() {
				value.channelName := newChannelName;
				send value to newChannelName;
			}
		}
		errorListener.l := on Error(channelName = channelName) as error {
			valueListener.quit();
			completedListener.quit();
			try {
				switch (errorHandler(error.exception, error.errorValue) as handlerResult) {
					case Observable : {
						Subscription s := handlerResult
											.subscribeDisconnected(SubscriptionHandler.create()
											                       		.onNext(_ForwardToChannel.create(newChannelName))
											                       		.onCompleted(_ForwardCompletedToMultipleChannels.create([channelName, newChannelName]))
											                       		.onError(_ForwardErrorToChannel.create(newChannelName)));
						on all Subscribe(channelName = channelName) {
							send Subscribe(s.channelName) to s.channelName;
							s.isConnected := true;
						}
						on all completed Unsubscribe(channelName = channelName) {
							send Unsubscribe(s.channelName) to s.channelName;
							s.isConnected := not subscriptionCount.isZero();
						}
					}
					default : {
						any v;
						for v in handlerResult.getEntries() {
							send Value(newChannelName, v) to newChannelName;
						}
					}
				}
			} catch (Exception e) {
				log "ErrorHandler threw exception, original exception was: " + e.toStringWithStackTrace() at ERROR;
				send Error(newChannelName, e, error.errorValue) to newChannelName;
			}
		}
		completedListener.l := on Complete(channelName = channelName) as complete {
			valueListener.quit();
			errorListener.quit();
			complete.channelName := newChannelName;
			send complete to newChannelName;
		}
		return result;
	}
	
	action catchError(action<Exception, any> returns any errorHandler) returns Observable {
		return catchErrorWithName(errorHandler, "Observable"+integer.getUnique().toString());
	}
	
	action skipWithName(integer n, string newChannelName) returns Observable {
		Observable result := createLinkedWithName(newChannelName);

		IntegerWrapper i := IntegerWrapper(n);
		
		ListenerWrapper valueListener := new ListenerWrapper;
		ListenerWrapper errorListener := new ListenerWrapper;
		ListenerWrapper completedListener := new ListenerWrapper;
		
		valueListener.l := on all Value(channelName = channelName) as value {
			if not subscriptionCount.isZero() {
				if i.isZero() {
					value.channelName := newChannelName;
					send value to newChannelName;
				} else {
					i.decrement();
				}
			}
		}
		errorListener.l := on Error(channelName = channelName) as error {
			valueListener.quit();
			completedListener.quit();
			error.channelName := newChannelName;
			send error to newChannelName;
		}
		completedListener.l := on Complete(channelName = channelName) as complete {
			valueListener.quit();
			errorListener.quit();
			complete.channelName := newChannelName;
			send complete to newChannelName;
		}
		
		return result;
	}
	
	action skip(integer n) returns Observable {
		return skipWithName(n, "Observable"+integer.getUnique().toString());
	}
}