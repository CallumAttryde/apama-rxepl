package com.industry.rx_epl.operators.internals;

using com.apama.exceptions.Exception;

using com.industry.rx_epl.IObserver;
using com.industry.rx_epl.IObserverBuilder;
using com.industry.rx_epl.IObservable;
using com.industry.rx_epl.ISubscription;
using com.industry.rx_epl.Subscription;
using com.industry.rx_epl.Subscriber;
using com.industry.rx_epl.utils.Utils;

/** @private */
event SwitchIfPaused {
	IObservable source;
	
	static action create(IObservable source) returns action<any> returns IObservable {
		return SwitchIfPaused(source).switchIfPaused;
	}
	
	action switchIfPaused(any paused) returns IObservable {
		if <boolean> paused {
			return (<action<> returns IObservable> any.newInstance("com.industry.rx_epl.Observable").getAction("never"))();
		} else {
			return source;
		}
	}
}

/** @private */
event PausableBufferedComplexPipe {
	IObservable trigger;
	
	static action create(IObservable trigger) returns action<IObservable> returns IObservable {
		return PausableBufferedComplexPipe(trigger).pausableBuffered;
	}
	
	action pausableBuffered(IObservable o) returns IObservable {
		IObservable pauser := trigger
			.scanWithInitial(invertBool, true)
			.switchMap(SwitchIfPaused.create(o));
	
		return o.buffer(pauser).mergeAll();
	}
	
	static action invertBool(any bool, any ignore) returns any {
		return not <boolean> bool;
	}
}