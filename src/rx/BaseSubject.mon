package com.industry.rx_epl;

event SubjectOnDisconnection {
	dictionary<integer, IObserver> subscribers;
	integer subscriberId;
	
	static action create(dictionary<integer, IObserver> subscribers, integer subscriberId) returns action<> {
		return SubjectOnDisconnection(subscribers, subscriberId).onDisconnect;
	}
	
	action onDisconnect() {
		subscribers.remove(subscriberId);
	}
}

event SubjectHandler {
	dictionary<integer, IObserver> subscribers;
	boolean isComplete;
	
	static action create() returns SubjectHandler {
		return SubjectHandler(new dictionary<integer, IObserver>, false);
	}
	
	action onConnection(IObserver subscriber) returns ISubscription {
		if not isComplete {
			subscribers.add(subscriber.getId(), subscriber);
			subscriber.onUnsubscribe(SubjectOnDisconnection.create(subscribers, subscriber.getId()));
		} else {
			subscriber.complete();
		}
		return Subscription.create(subscriber).asISubscription();
	}
	
	action next(any value) {
		IObserver s;
		for s in subscribers.values() {
			s.next(value);
		}
	}
	
	action error(any e) {
		IObserver s;
		for s in subscribers.values(){
			s.error(e);
		}		
	}
	
	action complete() {
		IObserver s;
		for s in subscribers.values() {
			s.complete();
			s.disconnect();
		}
		isComplete := true;
		subscribers.clear();
	}
}

event BaseSubject {	
	IObservable observable;
	
	action<any> next;
	action<any> error;
	action<> complete;
	
	static action create(IObservable observable, action<action<IObserver> returns ISubscription> setOnConnection) returns ISubject {
		SubjectHandler h := SubjectHandler.create();
		// Can't pull from a subject so the observable is hot
		BaseSubject s := BaseSubject(observable, h.next, h.error, h.complete);
		setOnConnection(h.onConnection);
		return s.asISubject();
	}

	action asISubject() returns ISubject {
		return ISubject(self, 
		                next, error, complete, asIObservable,
		                observable.connectObserver, observable.subscribe, observable.map, observable.publish, observable.connect, observable.refCount, observable.share, observable.take, observable.takeLast, observable.first, observable.last, observable.skip, observable.skipLast, observable.filter, observable.scan, observable.scanWithInitial, observable.distinct, observable.distinctBy, observable.combineLatest, observable.withLatestFrom, observable.delay, observable.async, observable.do, observable.publishReplay, observable.shareReplay, observable.takeUntil, observable.repeat, observable.flatMap, observable.merge, observable.zip, observable.switchOnNext, observable.skipUntil, observable.elementAt, observable.reduce, observable.reduceWithInitial, observable.toStream, observable.catchError, observable.retry, observable.observeOn, observable.groupBy, observable.publishToContext, observable.publishToChannel, observable.observeOnNewContext, observable.every, observable.contains, observable.takeWhile, observable.skipWhile, observable.concat, observable.startWith, observable.defaultIfEmpty, observable.ignoreElements, observable.count, observable.sum, observable.sumInteger, observable.sumFloat, observable.sumDecimal, observable.concatString, observable.max, observable.maxInteger, observable.maxFloat, observable.maxDecimal, observable.min, observable.minInteger, observable.minFloat, observable.minDecimal, observable.average, observable.averageDecimal, observable.sequenceEqual);
	}
	
	action asIObservable() returns IObservable {
		return IObservable(self, 
		                   observable.connectObserver, observable.subscribe, observable.map, observable.publish, observable.connect, observable.refCount, observable.share, observable.take, observable.takeLast, observable.first, observable.last, observable.skip, observable.skipLast, observable.filter, observable.scan, observable.scanWithInitial, observable.distinct, observable.distinctBy, observable.combineLatest, observable.withLatestFrom, observable.delay, observable.async, observable.do, observable.publishReplay, observable.shareReplay, observable.takeUntil, observable.repeat, observable.flatMap, observable.merge, observable.zip, observable.switchOnNext, observable.skipUntil, observable.elementAt, observable.reduce, observable.reduceWithInitial, observable.toStream, observable.catchError, observable.retry, observable.observeOn, observable.groupBy, observable.publishToContext, observable.publishToChannel, observable.observeOnNewContext, observable.every, observable.contains, observable.takeWhile, observable.skipWhile, observable.concat, observable.startWith, observable.defaultIfEmpty, observable.ignoreElements, observable.count, observable.sum, observable.sumInteger, observable.sumFloat, observable.sumDecimal, observable.concatString, observable.max, observable.maxInteger, observable.maxFloat, observable.maxDecimal, observable.min, observable.minInteger, observable.minFloat, observable.minDecimal, observable.average, observable.averageDecimal, observable.sequenceEqual);
	}
}