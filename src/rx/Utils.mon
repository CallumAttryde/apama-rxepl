package com.industry.rx_epl;

using com.apama.exceptions.Exception;

event Utils {
	/**
	 * Attempts to convert the provided any to a sequence of values
	 */
	static action anyToSequenceAny(any value) returns sequence<any> {
		switch(value) {
			case string: {
				return [<any>value];
			}
			default: {
				if value.getTypeName().find("optional<") = 0 {
					if value.valueToString() = "optional()" {
						return new sequence<any>;
					}
					string actualType := value.getTypeName().substring("optional<".length(), -1);
					string actualValue := value.valueToString().substring("optional(".length(), -1);
					value := any.parse("any(" + actualType + "," + actualValue + ")");
					return anyToSequenceAny(value);
				}
				return value.getEntries();
			}
		}
	}
	
	static action callAsync(action<> callback) {
		on wait(0.0) {
			callback();
		}
	}

	static action noOp() {}
}

event WrappedInteger {
	integer value;
	
	action get() returns integer {
		return value;
	}
	
	action increment() {
		value := value + 1;
	}
}

/**
 * Limits the max number of synchronous calls to an action, after which the call will be made asynchronously.
 * This stops stackoverflow exceptions
 */
event LimitSyncInvoke {
	integer countLimit;
	action<> method;
	integer count;
	boolean hasLogged;
	
	static action create(integer countLimit, action<> method) returns LimitSyncInvoke {
		return LimitSyncInvoke(countLimit, method, 0, false);
	}
	
	action invoke() {
		count := count + 1;
		if count - 1 < countLimit {
			method();
		} else {
			if not hasLogged {
				log "Exceeded max number of synchronous invocations (" + countLimit.toString() + "), splitting into async batches of " + countLimit.toString() + ". Consider making the observable async." at INFO;
				hasLogged := true;
			}
			Utils.callAsync(method);
		}
		count := 0;
	}
}