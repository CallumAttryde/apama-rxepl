package com.industry.rx_epl;

using com.apama.exceptions.Exception;

event Observable {	
	action<IObserver> returns ISubscription onConnection;
	
	boolean connectable;
	IDisposable connection;
	
	action<> returns IDisposable connect;
	
	static action _create() returns Observable {
		Observable o := new Observable;
		o.connect := invalidConnect;
		return o;
	}
	static action _createAsIObservable() returns IObservable {
		Observable o := new Observable;
		o.connect := invalidConnect;
		return o.asIObservable();
	}
	
	static action _createConnectable(IDisposable connection, action<> returns IDisposable connect) returns Observable {
		Observable o := new Observable;
		o.connect := connect;
		o.connectable := true;
		o.connection := connection;
		return o;
	}

	static action create(action<IResolver> resolver) returns IObservable {
		// A user defined resolver cannot handle pull requests so it's hot
		Observable o := _create();
		
		o.onConnection := CreateOnConnection.create(resolver);
		
		return o.asIObservable();
	}

	static action fromValues(any values) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FromOnConnection.create(values);
		
		return o.asIObservable();
	}
	
	static action fromIterator(action<> returns any iterator) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FromIteratorOnConnection.create(iterator);
		
		return o.asIObservable();
	}
	
	static action just(any value) returns IObservable {
		Observable o := _create();
		
		o.onConnection := JustOnConnection.create(value);
		
		return o.asIObservable();		
	}
	
	/**
	 * Note: the channel listener start asynchronously - so won't receive events until a short time later
	 */
	static action fromChannel(string channelName) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FromChannelOnConnection.create(channelName);
		
		return o.asIObservable();		
	}

	/**
	 * Generates a series of event with an incrementing float value
	 * @param interval the time between subsequent events
	 */
	static action interval(float seconds) returns IObservable {
		Observable o := _create();
		
		o.onConnection := IntervalOnConnection.create(seconds);
		
		return o.asIObservable();	
	}
	
	static action range(integer start, integer end) returns IObservable {
		Observable o := _create();
		
		o.onConnection := RangeOnConnection.create(start, end);
		
		return o.asIObservable();	
	}
	
	static action repeat(any value, integer count) returns IObservable {
		Observable j := <Observable> just(value).observable;
		return j.repeatObservable(count);
	}
	
	static action combineLatest(sequence<IObservable> observables, action<sequence<any> > returns any combiner) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.combineLatest(others, combiner);
	}
	
	static action start(action<> returns any valueGenerator) returns IObservable {
		Observable o := _create();
		
		o.onConnection := StartOnConnection.create(valueGenerator);
		
		return o.asIObservable();
	}
	
	static action merge(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.merge(others);
	}
	
	static action zip(sequence<IObservable> observables, action<sequence<any> > returns any combiner) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.zip(others, combiner);
	}
	
	static action fromStream(stream<any> valueStream) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FromStreamOnConnection.create(valueStream);
		
		return o.asIObservable();
	}
	
	static action timer(any value, float delay) returns IObservable {
		return just(value).delay(delay);
	}

	/**
	 * Must call .connect() to start receiving values
	 */
	static action receiveFromChannel(string channelName) returns IObservable {
		IDisposable connection := new IDisposable;
		Observable o := _createConnectable(connection, ReceiveFromConnect.createChannel(connection, channelName));
		
		o.onConnection := ReceiveFromOnConnection.createChannel(channelName);
		
		return o.asIObservable();
	}

	/**
	 * Must call .connect() to start receiving values
	 */
	static action receiveFromContext(string id, context upstreamContext) returns IObservable {
		IDisposable connection := new IDisposable;
		Observable o := _createConnectable(connection, ReceiveFromConnect.createContext(connection, id, upstreamContext));
		
		o.onConnection := ReceiveFromOnConnection.createContext(id, upstreamContext);
		
		return o.asIObservable();
	}
	
	static action concat(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.concat(others);
	}
	
	action connectObserver(IObserver observer) returns ISubscription {
		return onConnection(observer);
	}
	
	action subscribe(Subscriber subscriber) returns ISubscription {
		Observable o := _create();
		
		IObserver observer := subscriber.asIObserver();

		o.onConnection := SubscribeOnConnection.create(onConnection); 
		
		return o.onConnection(observer);
	}
	
	action map(action<any> returns any mapper) returns IObservable {
		Observable o := _create();		
		o.onConnection := MapOnConnection.create(onConnection, mapper);
		
		return o.asIObservable();
	}
	
	action publish() returns IObservable {
		IDisposable connection := IDisposable(new action<>);
		PublishHandler p := PublishHandler.create(onConnection, connection);
		Observable o := _createConnectable(connection, p.connect);
		
		o.onConnection := p.onConnection;
		
		return o.asIObservable();
	}
	
	action refCount() returns IObservable {
		if not connectable {
			throw Exception("Can only refCount a published Observable", "UnsupportedOperation");
		}
		Observable o := _create();
		o.onConnection := RefCountOnConnection.create(connection, connect, onConnection);
		return o.asIObservable();
	}
	
	action share() returns IObservable {
		return publish().refCount();
	}

	action take(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeOnConnection.create(onConnection, count);
		
		return o.asIObservable();	
	}

	action takeLast(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeLastOnConnection.create(onConnection, count);
		
		return o.asIObservable();	
	}

	action first() returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeOnConnection.create(onConnection, 1);
		
		return o.asIObservable();	
	}
	
	action last() returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeLastOnConnection.create(onConnection, 1);
		
		return o.asIObservable();	
	}
	
	action skip(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := SkipOnConnection.create(onConnection, count);
		
		return o.asIObservable();			
	}

	action skipLast(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := SkipLastOnConnection.create(onConnection, count);
		
		return o.asIObservable();			
	}
	
	action filter(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FilterOnConnection.create(onConnection, predicate);
		
		return o.asIObservable();			
	}

	action scan(action<any, any> returns any scanner) returns IObservable {
		Observable o := _create();
		
		o.onConnection := ScanOnConnection.create(onConnection, scanner, new any, false);
		
		return o.asIObservable();		
	}
	
	action scanWithInitial(action<any, any> returns any scanner, any initialValue) returns IObservable {
		Observable o := _create();
		
		o.onConnection := ScanOnConnection.create(onConnection, scanner, initialValue, true);
		
		return o.asIObservable();		
	}
	
	action distinct() returns IObservable {
		Observable o := _create();
		
		o.onConnection := DistinctByOnConnection.create(onConnection, new action<any> returns any);
		
		return o.asIObservable();		
	}
	
	action distinctBy(action<any> returns any keyGetter) returns IObservable {
		Observable o := _create();
		
		o.onConnection := DistinctByOnConnection.create(onConnection, keyGetter);
		
		return o.asIObservable();		
	}
	
	action combineLatestFromInstance(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		
		sequence<IObservable> observables := [self.asIObservable()];
		observables.appendSequence(otherObservables);
		
		o.onConnection := CombineLatestOnConnection.create(observables, combiner);
		
		return o.asIObservable();	
	}
	
	action withLatestFrom(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		
		o.onConnection := WithLatestFromOnConnection.create(self.asIObservable(), otherObservables, combiner);
		
		return o.asIObservable();	
	}
	
	action delay(float seconds) returns IObservable {
		Observable o := _create();
		
		o.onConnection := DelayOnConnection.create(onConnection, seconds);
		
		return o.asIObservable();
	}
	
	action async() returns IObservable {
		Observable o := _create();
		
		o.onConnection := DelayOnConnection.create(onConnection, 0.0);
		
		return o.asIObservable();
	}
	
	action do(Subscriber doer) returns IObservable {
		Observable o := _create();
		
		o.onConnection := DoOnConnection.create(onConnection, doer);
		
		return o.asIObservable();
	}
	
	/**
	 * Note: on termination of the connection the replay buffer will be emptied
	 */
	action publishReplay(integer count) returns IObservable {
		IDisposable connection := IDisposable(new action<>);
		
		Observable publishObservable := <Observable> publish().observable;
		PublishReplayHandler replayHandler := PublishReplayHandler.create(publishObservable.connection, connection, publishObservable.connect, publishObservable.onConnection, count);
		Observable o := _createConnectable(connection, replayHandler.downstreamConnect);
		
		o.onConnection := replayHandler.onConnection;
		
		return o.asIObservable();
	}
	
	/**
	 * Note: Unlike in rxjs v5.5 (but like rxjs v5.4) - if the refcount drops to 0 then the source will be disconnected from and the replay buffer will be emptied
	 */
	action shareReplay(integer count) returns IObservable {
		return publishReplay(count).refCount();
	}
	
	action takeUntil(IObservable until) returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeUntilOnConnection.create(onConnection, until);
		
		return o.asIObservable();
	}
	
	// Called repeat when accessed via the interface
	action repeatObservable(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := RepeatOnConnection.create(onConnection, count);
		
		return o.asIObservable();
	}
	
	action flatMap(action<any> returns any mapper) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FlatMapOnConnection.create(onConnection, mapper);
		
		return o.asIObservable();
	}
	
	action mergeFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();
		
		sequence<IObservable> observables := [self.asIObservable()];
		observables.appendSequence(otherObservables);
		
		o.onConnection := MergeOnConnection.create(observables);
		
		return o.asIObservable();
	}
	
	action zipFromInstance(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		
		sequence<IObservable> observables := [self.asIObservable()];
		observables.appendSequence(otherObservables);
		
		o.onConnection := ZipOnConnection.create(observables, combiner);
		
		return o.asIObservable();
	}
	
	action switchOnNext() returns IObservable {
		return flatMap(SwitchOnNext.flatMapper);
	}
	
	action skipUntil(IObservable until) returns IObservable {
		Observable o := _create();
		
		o.onConnection := SkipUntilOnConnection.create(onConnection, until);
		
		return o.asIObservable();
	}
	
	action elementAt(integer n) returns IObservable {
		return take(n).skip(n-1);
	}
	
	action reduce(action<any, any> returns any reducer) returns IObservable {
		return scan(reducer).last();
	}
	
	action reduceWithInitial(action<any, any> returns any reducer, any initialValue) returns IObservable {
		return scanWithInitial(reducer, initialValue).last();
	}
	
	/**
	 * The stream will automatically quit and dispose if/when the observable does.
	 * It is necessary to call dispose on the disposableStream if quit is called manually on the stream.
	 */
	action toStream() returns DisposableStream {
		return ToStream.create(self.asIObservable());
	}
	
	action catchError(IObservable onCatch) returns IObservable {
		Observable o := _create();
		
		o.onConnection := CatchErrorOnConnection.create(onConnection, onCatch);
		
		return o.asIObservable();
	}
	
	action retry(integer retryCount) returns IObservable {
		Observable o := _create();
		
		o.onConnection := RetryOnConnection.create(onConnection, retryCount);
		
		return o.asIObservable();
	}
	
	/**
	 * Note: Unsubscribe should be called on the the ISubscription once the downstreams have finished.
	 */
	action observeOn(context observingContext, action<IObservable> observableConstructor) returns ISubscription {
		return ObserveOnHandler.createAndStart(publishToContext, receiveFromContext, observingContext, observableConstructor);
	}
	
	action groupBy(action<any> returns any groupBy) returns IObservable {
		Observable o := _create();
		
		o.onConnection := GroupByOnConnection.create(_createAsIObservable, getSetOnConnection, onConnection, groupBy);
		
		return o.asIObservable();		
	}

	action publishToContext(string id, context context) returns ISubscription {
		return PublishToHandler.createContext(onConnection, id, context);
	}
	
	action publishToChannel(string channelName) returns ISubscription {
		return PublishToHandler.createChannel(onConnection, channelName);
	}

	/**
	 * Note: Unsubscribe should be called on the the ISubscription once the downstreams have finished.
	 */
	action observeOnNewContext(action<IObservable> observableConstructor) returns ISubscription {
		return ObserveOnHandler.createAndStart(publishToContext, receiveFromContext, context("ObserveOnNewContext" + integer.getUnique().toString(), false), observableConstructor);
	}
	
	action every(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		
		o.onConnection := EveryOnConnection.create(onConnection, predicate);
		
		return o.asIObservable();	
	}

	action contains(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		
		o.onConnection := ContainsOnConnection.create(onConnection, predicate);
		
		return o.asIObservable();	
	}
	
	action takeWhile(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeWhileOnConnection.create(onConnection, predicate);
		
		return o.asIObservable();	
	}

	action skipWhile(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		
		o.onConnection := SkipWhileOnConnection.create(onConnection, predicate);
		
		return o.asIObservable();	
	}
	
	action concatFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();
		
		sequence<IObservable> observables := [self.asIObservable()];
		observables.appendSequence(otherObservables);
		
		o.onConnection := ConcatOnConnection.create(observables);
		
		return o.asIObservable();	
	}
	
	static action invalidConnect() returns IDisposable {
		throw Exception("Can only connect a published Observable", "UnsupportedOperation");
	}
	
	action setOnConnection(action<IObserver> returns ISubscription onConnection) {
		self.onConnection := onConnection;
	}
	
	static action getSetOnConnection(IObservable o) returns action<action<IObserver> returns ISubscription> {
		return (<Observable>o.observable).setOnConnection;
	}
		
	action asIObservable() returns IObservable {
		return IObservable(self, 
		                   connectObserver, subscribe, map, publish, connect, refCount, share, take, takeLast, first, last, skip, skipLast, filter, scan, scanWithInitial, distinct, distinctBy, combineLatestFromInstance, withLatestFrom, delay, async, do, publishReplay, shareReplay, takeUntil, repeatObservable, flatMap, mergeFromInstance, zipFromInstance, switchOnNext, skipUntil, elementAt, reduce, reduceWithInitial, toStream, catchError, retry, observeOn, groupBy, publishToContext, publishToChannel, observeOnNewContext, every, contains, takeWhile, skipWhile, concatFromInstance);
	}
}