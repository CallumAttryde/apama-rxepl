package com.industry.rx_epl;

using com.apama.exceptions.Exception;

event Observable {	
	action<IObserver> returns ISubscription onConnection;
	
	boolean connectable;
	IDisposable connection;
	
	action<> returns IDisposable connect;
	
	static action _create() returns Observable {
		Observable o := new Observable;
		o.connect := invalidConnect;
		return o;
	}
	
	static action _createConnectable(IDisposable connection, action<> returns IDisposable connect) returns Observable {
		Observable o := new Observable;
		o.connect := connect;
		o.connectable := true;
		o.connection := connection;
		return o;
	}

	static action create(action<IResolver> resolver) returns IObservable {
		// A user defined resolver cannot handle pull requests so it's hot
		Observable o := _create();
		
		o.onConnection := CreateOnConnection.create(resolver);
		
		return o.asIObservable();
	}

	static action fromValues(any values) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FromOnConnection.create(values);
		
		return o.asIObservable();
	}
	
	static action fromIterator(action<> returns any iterator) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FromIteratorOnConnection.create(iterator);
		
		return o.asIObservable();
	}
	
	static action just(any value) returns IObservable {
		Observable o := _create();
		
		o.onConnection := JustOnConnection.create(value);
		
		return o.asIObservable();		
	}
	
	/**
	 * Note: the channel listener start asynchronously - so won't receive events until a short time later
	 */
	static action fromChannel(string channelName) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FromChannelOnConnection.create(channelName);
		
		return o.asIObservable();		
	}

	/**
	 * Generates a series of event with an incrementing float value
	 * @param interval the time between subsequent events
	 */
	static action interval(float seconds) returns IObservable {
		Observable o := _create();
		
		o.onConnection := IntervalOnConnection.create(seconds);
		
		return o.asIObservable();	
	}
	
	static action range(integer start, integer end) returns IObservable {
		Observable o := _create();
		
		o.onConnection := RangeOnConnection.create(start, end);
		
		return o.asIObservable();	
	}
	
	action connectObserver(IObserver observer) returns ISubscription {
		return onConnection(observer);
	}
	
	action subscribe(Subscriber subscriber) returns ISubscription {
		Observable o := _create();
		
		IObserver observer := subscriber.asIObserver();

		o.onConnection := SubscribeOnConnection.create(onConnection); 
		
		return o.onConnection(observer);
	}
	
	action map(action<any> returns any mapper) returns IObservable {
		Observable o := _create();		
		o.onConnection := MapOnConnection.create(onConnection, mapper);
		
		return o.asIObservable();
	}
	
	action publish() returns IObservable {
		IDisposable connection := IDisposable(1, new action<>);
		PublishHandler p := PublishHandler.create(onConnection, connection);
		Observable o := _createConnectable(connection, p.connect);
		
		o.onConnection := p.onConnection;
		
		return o.asIObservable();
	}
	
	action refCount() returns IObservable {
		if not connectable {
			throw Exception("Can only refCount a published Observable", "UnsupportedOperation");
		}
		Observable o := _create();
		o.onConnection := RefCountOnConnection.create(connection, connect, onConnection);
		return o.asIObservable();
	}
	
	action share() returns IObservable {
		return publish().refCount();
	}

	action take(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeOnConnection.create(onConnection, count);
		
		return o.asIObservable();	
	}

	action takeLast(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeLastOnConnection.create(onConnection, count);
		
		return o.asIObservable();	
	}

	action first() returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeOnConnection.create(onConnection, 1);
		
		return o.asIObservable();	
	}
	
	action last() returns IObservable {
		Observable o := _create();
		
		o.onConnection := TakeLastOnConnection.create(onConnection, 1);
		
		return o.asIObservable();	
	}
	
	action skip(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := SkipOnConnection.create(onConnection, count);
		
		return o.asIObservable();			
	}

	action skipLast(integer count) returns IObservable {
		Observable o := _create();
		
		o.onConnection := SkipLastOnConnection.create(onConnection, count);
		
		return o.asIObservable();			
	}
	
	action filter(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		
		o.onConnection := FilterOnConnection.create(onConnection, predicate);
		
		return o.asIObservable();			
	}

	action scan(action<any, any> returns any scanner) returns IObservable {
		Observable o := _create();
		
		o.onConnection := ScanOnConnection.create(onConnection, scanner, new any, false);
		
		return o.asIObservable();		
	}
	
	action scanWithInitial(action<any, any> returns any scanner, any initialValue) returns IObservable {
		Observable o := _create();
		
		o.onConnection := ScanOnConnection.create(onConnection, scanner, initialValue, true);
		
		return o.asIObservable();		
	}
	
	action distinct() returns IObservable {
		Observable o := _create();
		
		o.onConnection := DistinctByOnConnection.create(onConnection, new action<any> returns any);
		
		return o.asIObservable();		
	}
	
	action distinctBy(action<any> returns any keyGetter) returns IObservable {
		Observable o := _create();
		
		o.onConnection := DistinctByOnConnection.create(onConnection, keyGetter);
		
		return o.asIObservable();		
	}
	
	action combineLatest(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		
		sequence<IObservable> observables := [self.asIObservable()];
		observables.appendSequence(otherObservables);
		
		o.onConnection := CombineLatestOnConnection.create(observables, combiner);
		
		return o.asIObservable();	
	}
	
	action withLatestFrom(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		
		sequence<IObservable> observables := [self.asIObservable()];
		observables.appendSequence(otherObservables);
		
		o.onConnection := WithLatestFromOnConnection.create(observables, combiner);
		
		return o.asIObservable();	
	}
	
	action delay(float seconds) returns IObservable {
		Observable o := _create();
		
		o.onConnection := DelayOnConnection.create(onConnection, seconds);
		
		return o.asIObservable();
	}
	
	action async() returns IObservable {
		Observable o := _create();
		
		o.onConnection := DelayOnConnection.create(onConnection, 0.0);
		
		return o.asIObservable();
		
	}
	
	static action invalidConnect() returns IDisposable {
		throw Exception("Can only connect a published Observable", "UnsupportedOperation");
	}
		
	action asIObservable() returns IObservable {
		return IObservable(self, 
		                   connectObserver, subscribe, map, publish, connect, refCount, share, take, takeLast, first, last, skip, skipLast, filter, scan, scanWithInitial, distinct, distinctBy, combineLatest, withLatestFrom, delay, async);
	}
}